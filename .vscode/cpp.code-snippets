{
	"快读": {
		"scope": "cpp",
		"prefix": "add_re",
		"body": [
			"class fastIO{private:char ibuf[50007],*p1=ibuf,*p2=ibuf,obuf[50007],*p3=obuf,sta[50];bool file_end=false;char get(){return p1==p2&&(p2=(p1=ibuf)+fread(ibuf,1,50007,stdin),p1==p2)?(file_end=true),char(EOF):*p1++;}void put(const char x){p3-obuf<50007?*p3++=x:(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x);}public:explicit operator bool(){return!file_end;}size_t flush(){size_t f=fwrite(obuf,p3-obuf,1,stdout);p3=obuf;*p3=0;return f;}fastIO&operator>>(char&t){for(t=get();!isgraph(t);t=get());return*this;}template<typename any>typename std::enable_if<std::is_same<any,char>::value,any>::type tpval(){char t;for(t=get();!isgraph(t);t=get());return t;}fastIO&operator>>(char*t){char c;for(c=get();!isgraph(c);c=get());for(;isgraph(c);c=get())*t=c,t++;*t=0;return*this;}fastIO&operator>>(std::string&t){t.clear();char c;for(c=get();!isgraph(c);c=get());for(;isgraph(c);c=get())t+=c;return*this;}template<typename any>typename std::enable_if<std::is_same<any,std::string>::value,any>::type tpval(){std::string t;char c;for(c=get();!isgraph(c);c=get());for(;isgraph(c);c=get())t+=c;return t;}template<typename any>typename std::enable_if<(std::is_signed<any>::value&&std::is_integral<any>::value&&!std::is_same<any,char>::value)||std::is_same<any,__int128_t>::value,fastIO>::type&operator>>(any&t){t=0;bool y=0;char c=get();for(;!isdigit(c);c=get())if(c==45)y=true;for(;isdigit(c);c=get())t=t*10+c-48;if(y==1)t=-t;return*this;}template<typename any>typename std::enable_if<(std::is_signed<any>::value&&std::is_integral<any>::value&&!std::is_same<any,char>::value)||std::is_same<any,__int128_t>::value,any>::type tpval(){any t=0;bool y=0;char c=get();for(;!isdigit(c);c=get())if(c==45)y=true;for(;isdigit(c);c=get())t=t*10+c-48;if(y==1)t=-t;return t;}template<typename any>typename std::enable_if<(std::is_unsigned<any>::value&&std::is_integral<any>::value&&!std::is_same<any,char>::value)||std::is_same<any,__uint128_t>::value,fastIO>::type&operator>>(any&t){t=0;char c=get();for(;!isdigit(c);c=get());for(;isdigit(c);c=get())t=t*10+c-48;return*this;}template<typename any>typename std::enable_if<(std::is_unsigned<any>::value&&std::is_integral<any>::value&&!std::is_same<any,char>::value)||std::is_same<any,__uint128_t>::value,any>::type tpval(){any t=0;char c=get();for(;!isdigit(c);c=get());for(;isdigit(c);c=get())t=t*10+c-48;return t;}template<typename any1,typename any2>fastIO&operator>>(std::pair<any1,any2>&t){return*this>>t.first>>t.second;}template<typename any1,typename any2>std::pair<any1,any2>tpval(){return std::pair<any1,any2>(tpval<any1>(),tpval<any2>());}template<typename any>fastIO&read(any&t){return*this>>t;}fastIO&read(char*t){char c;for(c=get();!isgraph(c);c=get());for(;isgraph(c);c=get())*t=c,t++;*t=0;return*this;}template<typename any,typename...args>fastIO&read(any&t1,args&...t2){return(*this>>t1).read(t2...);}fastIO&operator<<(const char t){put(t);return*this;}fastIO&operator<<(const char*t){for(;*t;t++)put(*t);return*this;}fastIO&operator<<(const std::string&t){for(const char it:t)put(it);return*this;}template<typename any>typename std::enable_if<(std::is_signed<any>::value&&std::is_integral<any>::value&&!std::is_same<any,char>::value)||std::is_same<any,__int128_t>::value,fastIO>::type&operator<<(any t){if(!t){put(48);return*this;}int len=0;if(t<0)t=-t,put(45);while(t)sta[len++]=char(t%10+48),t/=10;while(len--)put(sta[len]);return*this;}template<typename any>typename std::enable_if<(std::is_unsigned<any>::value&&std::is_integral<any>::value&&!std::is_same<any,char>::value)||std::is_same<any,__uint128_t>::value,fastIO>::type&operator<<(any t){if(!t){put(48);return*this;}int len=0;while(t)sta[len++]=char(t%10+48),t/=10;while(len--)put(sta[len]);return*this;}template<typename any1,typename any2>fastIO&operator<<(const std::pair<any1,any2>&t){return*this<<t.first<<' '<<t.second;}template<typename any>fastIO&write(const any&t){return*this<<t;}template<typename any,typename...args>fastIO&write(const any&t1,const args&...t2){return(*this<<t1).write(t2...);}~fastIO(){fwrite(obuf,p3-obuf,1,stdout);}}fio;",
		]
	},
	"模板2": {
		"scope": "cpp",
		"prefix": "add_main2",
		"body": [
			"//不向焦虑与抑郁投降，这个世界终会有我们存在的地方。",
			"#include<iostream>",
			"#include<cstdio>",
			"#include<algorithm>",
			"#include<cstring>",
			"#include<cassert>",
			"#include<tuple>",
			"#include<ctime>",
			"#include<random>",
			"#if __cplusplus>=202002L",
			"#include<ranges>",
			"namespace vw=std::views;",
			"#endif",
			"struct _time{~_time(){std::cerr<<\"\\n\\033[33;40m\"<<1.*clock()/CLOCKS_PER_SEC<<\"s\\033[37;40m\";}}_TM;",
			"#define siz(x) int((x).size())",
			"#define cauto const auto",
			"#define all(x) std::begin(x),std::end(x)",
			"#define rall(x) std::rbegin(x),std::rend(x)",
			"#define sqrt __builtin_sqrt",
			"#define fi first",
			"#define se second",
			"#define continue(x...) {x;continue;}",
			"#define break(x...) {x;break;}",
			"using std::cin;using std::cout;",
			"using std::max;using std::min;",
			"using std::tie;using std::ignore;",
			"template<typename any>constexpr any&cmin(any&x,any&&y){if(y<x)x=y;return x;}",
			"template<typename any>constexpr any&cmax(any&x,any&&y){if(x<y)x=y;return x;}",
			"template<typename any,typename...args>constexpr any&cmin(any&x,any&&y,args&&...z){if(y<x)x=y;return cmin(x,std::forward<any>(z)...);}",
			"template<typename any,typename...args>constexpr any&cmax(any&x,any&&y,args&&...z){if(x<y)x=y;return cmax(x,std::forward<any>(z)...);}",
			"using loli=long long;",
			"using unt=unsigned;",
			"using lolu=unsigned long long;",
			"using lodb=long double;",
			"using venti=__int128_t;",
			"using pii=std::pair<int,int>;",
			"using tiii=std::tuple<int,int,int>;",
			"using inlsi=const std::initializer_list<int>&;",
			"using bsi=std::basic_string<int>;",
			"using bsl=std::basic_string<loli>;",
			"using bsc=std::string;",
			"using std::operator\"\"s;",
			"#if __cplusplus>=201703L",
			"using bscv=std::string_view;",
			"using std::operator\"\"sv;",
			"#endif",
			"std::mt19937 rng(std::random_device{}());",
			"#define type std::pair<T1,T2>",
			"template<typename T1,typename T2>std::istream&operator>>(std::istream&x,type&y){return x>>y.fi>>y.se;}",
			"template<typename T1,typename T2>std::ostream&operator<<(std::ostream&x,const type&y){return x<<y.fi<<' '<<y.se;}",
			"template<typename T1,typename T2>type operator+(const type&x,const type&y){return{x.fi+y.fi,x.se+y.se};}",
			"template<typename T1,typename T2>type operator+=(type&x,const type&y){x.fi+=y.fi;x.se+=y.se;return x;}",
			"template<typename T1,typename T2>type operator-(const type&x,const type&y){return{x.fi-y.fi,x.se-y.se};}",
			"template<typename T1,typename T2>type operator-=(type&x,const type&y){x.fi-=y.fi;x.se-=y.se;return x;}",
			"#undef type",
			"template<typename any>any get(std::istream&x=cin){any y;x>>y;return y;}",
			"template<typename any>any&STLcls(any &x){any{}.swap(x);return x;}",
			"constexpr venti operator\"\"_vt(lolu x){return venti(x);}",
			"constexpr bool ying=false,yang=true;",
			"signed main(){",
			"//\tfreopen(\".in\",\"r\",stdin);",
			"//\tfreopen(\".out\",\"w\",stdout);",
			"\tstd::ios::sync_with_stdio(false);cin.tie(nullptr);",
			"\treturn 0;",
			"}"
		]
	},
	"线性筛质数": {
		"scope": "cpp",
		"prefix": "add_xxs",
		"body": [
			"for(int i=2;i<=n;i++){",
			"\tif(!pr[i])pt.emplace_back(i),miu[i]=-1,phi[i]=i-1;",
			"\tfor(int j:pt){",
			"\t\tif(i*j>n)break;else pr[i*j]=true;",
			"\t\tif(i%j==0){miu[i*j]=0;phi[i*j]=phi[i]*j;break;}",
			"\t\tphi[i*j]=phi[i]*(j-1);miu[i*j]=miu[i]*miu[j];",
			"\t}",
			"}"
		]
	},
	"添加事件": {
		"scope": "cpp",
		"prefix": "add_tm",
		"body": [
			"/*",
			"* @author: 蒟酱",
			"* @date: $CURRENT_YEAR_SHORT年$CURRENT_MONTH月$CURRENT_DATE日$CURRENT_HOUR时$CURRENT_MINUTE分$CURRENT_SECOND秒 $CURRENT_DAY_NAME",
			"*/"
		]
	},
	"td": {
		"prefix": "add_td",
		"body": [
			"/*",
			"*                 W@.......................................cI;. ................... IWWDb5IICdWbE  .. ",
			"*               c@j                                          .::.                    .j@Wdc7c772BL    ",
			"*             IWp   ......................................... .,cc;. ................   L@NJJIIc2@: . ",
			"*           .W@,  .. ;:.....;7.................................. .;Lc. ........,c: ....,. 7WOL72W6 .. ",
			"*          kWc  ....c;......6:...................................   ;7c .........c..... :C: pB6@cc .. ",
			"*         B@       I.      :2       ............................ :,. .;I, ...... ,c ....  DD c@  6... ",
			"*        N2       I.       :J   ......... .........,......... .:c;.... .j; ...... 7,.....  NO.;b p, . ",
			"*       S;       L.        Bg ...........: ........;;. . . .,;;;........ 7c ..... ;c .....  S.cScD; . ",
			"*     .6.       ;c  ..... j@W  ......... Sd   ..... ,;, .,;;;.. ......... cc .... :c ...... ;A Jd@; . ",
			"*    ;b: .......2....... jD.W, ......... .@dc,   ....:cJc,   ............. ;; ....:L ....... Sj jWc . ",
			"*   5D  ...... 7; ;;:.  cB. E@  ..:...... IA;kdj;   ... ,::.          ..... I,... ;; ........ W  kj . ",
			"*  O6 ,....... k  ..::.k@c;; W@   c; ..... Df :jEDp5;,   ..,:..,,;;;:.      ;7 .  j, ........ Ig ;I . ",
			"* Wc f2 ..... 7E  .   SB;;:,. CNc  ;;   ..  gp    :cfdDSOjC6gNObgd5jjjj7;.   J   cj .........  @ .C . ",
			"*   gW .....  B2 .   D5         c57;;c.  ..  AB       .C@Wg; ..,;;.;cLL5ONj  c: ;W. .......... Ec;; . ",
			"*  6W. ..... .W;   ;Dc:2NWW@WW@D7;;;jkgpc.    J@c     5@D   :cjIc.    .,;cN@dSN.@L ..........  :WA. . ",
			"* WfI  ..... cB;  SACWWWDS7;:;Ib@W@.  .c2dkj;: .DWc       pW@W@W@WWA.      A@BfO5  ........ ,,  WB .. ",
			"* :;c ...... Cp.6EjBW@.           ,       .;I25jINk      @W2CIIJjJjpWc      B@@j  ........  WL  W2  . ",
			"*  d. ...... fWBI @Wj    ,DW@W@gj.                      :W7cc77JLLccdW,     .Wj  ........  dbE  A2 .. ",
			"* .6 ....... D@  OW7    ;WWDAEOOD@N   .                 .WJ7jIjjCjLBS       A6  ........  jd.N  OO d. ",
			"* c5 ....... cc  Wg     @WfCL7c7cc@W       . .   . . .   WEL22jjIjcbD5A.   AD  ........  6@bAW. 6O @L ",
			"* pL  ........d  Wk     W5ccJLIIL6O;    .     . . . .    IWj:.......:kW.  gD  .......  .Bbc;.g: Nk 2E ",
			"* OL :,...... f; WS     @DcJJC2fjDN;E:   . .   . .   .    cOj5I5jj22Lj:  BE  ......   CWC.   D: @W j.C",
			"* Aj ;; ..... .B ID     c@jj2Lc:,.:kWI      . . .     .       : .;:  :. BO  .....   jWN,     B ;BCj,L ",
			"* cE SB  ..... ;@        j@j,.,;cjC7:          . .     .     :;..:.... Eg  ....  :6WA:      .B W jB S.",
			"*  g 5Dp  ..... ;W.       ;2cIC7c.                                    .@  .   .7pNC.        jjD; @Bc J",
			"*  j2c.;@;   ... :Wc   :;. ..                      .   . . .      ;   dA   .J6fJ.           WI,:@c b6 ",
			"*   @p2 .bg7.      AW, ;;..;.           .  .:.:;ccL@E   .      ;pcB   Dj  bgj.             ,D2bN.   ;@",
			"*    @@   :Wbbc:.   :gf          . . .  :jIIcjJc;c:,:  .   .   .kf.   2D.W7      :EL:,,;;jObjc.  ... ,",
			"*     d@. ,c .NDk65c. Jgc     .   .                   .   . .         .@W;     7NDCfDDNbAkjc.   ..... ",
			"*      ., D:  .D;  cLC;,Og   . . . . . .             . .               .b.   kBf ;j,:::::;;;cc. ..... ",
			"*        Sd ..  Ob:   ,6;@g                         .   .     . . .       :pWb;   g;;;;;;;;;;cL:. ....",
			"*       EA ....  ;N@5:  c@2                              . .           .Iggk;;;   kd:;;;;;;;;;;L;  ..5",
			"*      DE   ... ,;;;fbDkc;.   2dEOS5J,  ....,,7ddc    . .           .jgBkJ2.;;, . ;B:;c;;;;;;;c;7;.  j",
			"*    .@j   c.. :cc;;::7c.cccc@k;;;cL55LC2dOE6bO2cAp            ... 5@bc:.@c  . .  LD,;;;;;;;;;;c;L;  .",
			"*   :W;  cNp  ,7c;;;;;2k    @7.LS;:::,:,,,::;:;;c:@L    ..,:;;;;;:.@f ..5B  ...  :B:::::;;;;;;;;c;7;. ",
			"*  ;W. .DcW  .cc;;;;;;;Bc  Nd:;c;ccJ55fOOpEpdpkdSS6gDgNd,:;;;;:;::.N@SS5@; ...  cWpkEE6k7:;;;;;;;;;7; ",
			"* Ng  :W j6  ;7;;;;;;kJck;cdc7JJLcc;;::..              @S.::;::::,,.,.cBW  ... jg:;;cccIb@;;;;c;c;;;L.",
			"* B  .@. W. .Iccccc;JW                                 Og.:;:;:;:,..:dg5@, .. jB         Wc;;ccccccccc",
			"*    @J ,@  ;cc;c;;;pp                      c2k5Sk6dbL.kb.:::::,:cdg@AI.W;   :W         IDk;c;c;c;c;c;",
			"*                                                                                                    ;",
			"*/"
		]
	},
	"线性筛": {
		"scope": "cpp",
		"prefix": "add_prime",
		"body": [
			"for(int i=2;i<N;i++){",
			"\tif(!pr[i])pt+=i;",
			"\tfor(int j:pt){",
			"\t\tif(i*j>=N)break;",
			"\t\tpr[i*j]=true;",
			"\t\tif(i%j==0)break;",
			"\t}",
			"}"
		]
	},
	"快速幂": {
		"scope": "cpp",
		"prefix": "add_qp",
		"body": [
			"constexpr int qp(int a,int b,int t=1){for(;b;b>>=1,a=mul({a,a}))if(b&1)t=mul({a,t});return t;}"
		]
	},
	"动态开点权值线段树": {
		"scope": "cpp",
		"prefix": "add_wstn",
		"body": [
			"struct stn{int ls,rs,data;}s[kZ];",
			"#define nls (s[now].ls)",
			"#define nrs (s[now].rs)",
			"#define mid ((l+r)>>1)",
			"void updata(int &now,int l,int r,int x){",
			"\tif(!now)now=++len;",
			"\tif(l==r){s[now].data=1;return;}",
			"\tx<=mid?updata(nls,l,mid,x):updata(nrs,mid+1,r,x);",
			"\ts[now].data=s[nls].data+s[nrs].data;",
			"}",
			"int query(int now,int l,int r,int x){",
			"\tif(l==r)return l;",
			"\treturn x<=s[nls].data?query(nls,l,mid,x):query(nrs,mid+1,r,x-s[nls].data);",
			"}",
			"int merge(int x,int y,int l,int r){",
			"\tif(!x||!y)return x|y;",
			"\tif(l==r)return s[x].data+=s[y].data,x;",
			"\ts[x].ls=merge(s[x].ls,s[y].ls,l,mid);",
			"\ts[x].rs=merge(s[x].rs,s[y].rs,mid+1,r);",
			"\ts[x].data=s[s[x].ls].data+s[s[x].rs].data;return x;",
			"}"
		]
	},
	"最小/大值检查": {
		"scope": "cpp",
		"prefix": "add_chk",
		"body": [
			"template<typename any>inline void cmin(any &x,const any &y){if(y<x)x=y;}",
			"template<typename any>inline void cmax(any &x,const any &y){if(x<y)x=y;}",
			"template<typename any,typename...args>inline void cmax(any &x,const any &y,const args &...z){cmax(x,y);cmax(x,z...);}",
			"template<typename any,typename...args>inline void cmin(any &x,const any &y,const args &...z){cmin(x,y);cmin(x,z...);}"
		]
	},
	"mt19937 随机数": {
		"scope": "cpp",
		"prefix": "add_rng",
		"body": [
			"std::mt19937 rng(std::random_device{}());"
		]
	},
	"无旋 Treap": {
		"scope": "cpp",
		"prefix": "add_treap",
		"body": [
			"struct treap{",
			"\tstruct node{",
			"\t\tnode *ls=nullptr,*rs=nullptr;",
			"\t\tint val=0,pri=rng(),siz=0;",
			"\t\tnode(int k):ls(nullptr),rs(nullptr),val(k),pri(rng()),siz(1){}",
			"\t\tnode *updata(){siz=1+(ls?ls->siz:0)+(rs?rs->siz:0);return this;}",
			"\t};",
			"\tnode *rt=nullptr;",
			"\tnode *merge(node *x,node *y){",
			"\t\tif(!x)return y;",
			"\t\tif(!y)return x;",
			"\t\tif(x->pri<y->pri)return x->rs=merge(x->rs,y),x->updata();",
			"\t\telse return y->ls=merge(x,y->ls),y->updata();",
			"\t}",
			"\tvoid split(node *now,int k,node *&x,node *&y){",
			"\t\tif(!now){x=y=nullptr;return;}",
			"\t\tif(now->val<=k)x=now,split(now->rs,k,now->rs,y);",
			"\t\telse y=now,split(now->ls,k,x,now->ls);",
			"\t\tnow->updata();",
			"\t}",
			"\tnode *kth(node *now,int k){",
			"\t\tfor(;;){",
			"\t\t\tint sum=(now->ls)?now->ls->siz:0;",
			"\t\t\tif(k<=sum)now=now->ls;",
			"\t\t\telse if(k==sum+1)return now;",
			"\t\t\telse k-=sum+1,now=now->rs;",
			"\t\t}",
			"\t}",
			"\tvoid insert(int k){",
			"\t\tnode *x=nullptr,*y=nullptr;",
			"\t\tsplit(rt,k,x,y);",
			"\t\trt=merge(merge(x,new node(k)),y);",
			"\t}",
			"\tvoid erase(int k){",
			"\t\tnode *x=nullptr,*y=nullptr,*z=nullptr;",
			"\t\tsplit(rt,k,x,z);",
			"\t\tsplit(x,k-1,x,y);",
			"\t\ty=merge(y->ls,y->rs);",
			"\t\trt=merge(merge(x,y),z);",
			"\t}",
			"\tint order(int k){",
			"\t\tnode *x=nullptr,*y=nullptr;",
			"\t\tsplit(rt,k-1,x,y);",
			"\t\tint res=(x?x->siz:0)+1;",
			"\t\trt=merge(x,y);",
			"\t\treturn res;",
			"\t}",
			"\tint operator[](int k){",
			"\t\treturn kth(rt,k)->val;",
			"\t}",
			"\tint prev(int k){",
			"\t\tnode *x=nullptr,*y=nullptr;",
			"\t\tsplit(rt,k-1,x,y);",
			"\t\tint res=kth(x,x->siz)->val;",
			"\t\trt=merge(x,y);",
			"\t\treturn res;",
			"\t}",
			"\tint next(int k){",
			"\t\tnode *x=nullptr,*y=nullptr;",
			"\t\tsplit(rt,k,x,y);",
			"\t\tint res=kth(y,1)->val;",
			"\t\trt=merge(x,y);",
			"\t\treturn res;",
			"\t}",
			"};"
		]
	},
	"二分图最大匹配 匈牙利算法": {
		"scope": "cpp",
		"prefix": "add_xyl",
		"body": [
			"bool dfs(int u){",
			"\tfor(int v:g[u]){",
			"\t\tif(vis[v])continue;",
			"\t\tvis[v]=true;",
			"\t\tif(!chs[v]||dfs(chs[v]))return chs[v]=u,true;",
			"\t}",
			"\treturn false;",
			"}"
		]
	},
	"强连通分量/缩点": {
		"scope": "cpp",
		"prefix": "add_tarjan1",
		"body": [
			"void tarjan(int u){",
			"\tdfn[u]=low[u]=++dc;",
			"\ts.push(u);",
			"\tfor(int v:g1[u])",
			"\t\tif(!dfn[v])tarjan(v),cmin(low[u],low[v]);",
			"\t\telse if(!bl[v])cmin(low[u],dfn[v]);",
			"\tif(low[u]==dfn[u]){",
			"\t\tbl[u]=++n2;vil[n2]+=u;",
			"\t\tfor(;s.top()!=u;s.pop())bl[s.top()]=n2,vil[n2]+=s.top();",
			"\t\ts.pop();",
			"\t}",
			"}"
		]
	},
	"分数": {
		"scope": "cpp",
		"prefix": "add_fraction",
		"body": [
			"struct fraction{",
			"\tint up,dw;",
			"\tstatic int get_len(int x,int l=0){while(x)x/=10,l++;return l;}",
			"\tstatic int gcd(int a,int b){return std::__detail::__gcd(unsigned(abs(a)),unsigned(abs(b)));}",
			"\tstatic int lcm(int a,int b){return a/gcd(a,b)*b;}",
			"\tfraction():up(0),dw(1){}",
			"\tfraction(int a,int b):up(a),dw(b){}",
			"\tfraction operator+(){return fraction(+up,+dw);}",
			"\tfraction operator-(){return fraction(-up,-dw);}",
			"\tfraction operator~(){return fraction(dw,up);}",
			"\tfraction &updata(){int g=gcd(up,dw);up/=g,dw/=g;return *this;}",
			"\tfriend void operator|(fraction &x,fraction &y){int l=lcm(x.dw,y.dw);x.up*=l/x.dw;y.up*=l/y.dw;x.dw=y.dw=l;}",
			"\tfriend fraction operator+(fraction x,fraction y){x|y;x.up+=y.up;return x.updata();}",
			"\tfriend fraction operator-(fraction x,fraction y){x|y;x.up-=y.up;return x.updata();}",
			"\tfriend fraction operator*(fraction x,fraction y){return fraction(x.up*y.up,x.dw*y.dw).updata();}",
			"\tfriend fraction operator*(fraction x,const int &y){return fraction(x.up*y,x.dw).updata();}",
			"\tfriend fraction operator/(fraction x,fraction y){return (x*~y).updata();}",
			"\tfriend std::ostream &operator<<(std::ostream &out,fraction t){",
			"\t\tbool op=0;",
			"\t\tif(t.up<0)op=1,t.up=-t.up;",
			"\t\tint cnt=t.up/t.dw,sp1=get_len(cnt)+op;",
			"\t\tt.up-=cnt*t.dw;",
			"\t\tif(!t.up)return cout<<(op?-cnt:cnt);",
			"\t\tfor(int i=1;i<=sp1;i++)out<<' ';",
			"\t\tout<<t.up<<'\\n';",
			"\t\tif(op)out<<'-';",
			"\t\tout<<cnt;",
			"\t\tfor(int i=1,sp2=get_len(t.dw);i<=sp2;i++)out<<'-';",
			"\t\tout<<'\\n';",
			"\t\tfor(int i=1;i<=sp1;i++)out<<' ';",
			"\t\treturn out<<t.dw<<'\\n';",
			"\t}",
			"};"
		]
	},
	"exgcd": {
		"scope": "cpp",
		"prefix": "add_exgcd",
		"body": [
			"inline void exgcd(int a,int b,int &x,int &y){if(!b){x=1,y=0;return;}exgcd(b,a%b,y,x);y-=a/b*x;}"
		]
	},
	"取模函数": {
		"scope": "cpp",
		"prefix": "add_mod",
		"body": [
			"inline int add0(int _x,int _y){return (_x+=_y)<MOD?_x:_x-MOD;}",
			"template<typename...args>inline int add0(int _x,args..._y){return (_x+=add0(_y...))<MOD?_x:_x-MOD;}",
			"inline int&add1(int&_x,int _y){return (_x+=_y)<MOD?_x:_x-=MOD;}",
			"template<typename...args>inline int&add1(int&_x,args..._y){return (_x+=add0(_y...))<MOD?_x:_x-=MOD;}",
			"inline int add0(inlsi _x){int _y=0;for(int _i:_x)add1(_y,_i);return _y;}",
			"inline int&add1(int&_x,inlsi _y){return add1(_x,add0(_y));}",
			"inline int sub0(int _x,int _y){return (_x-=_y)<0?_x+MOD:_x;}",
			"template<typename...args>inline int sub0(int _x,args..._y){return (_x-=add0(_y...))<0?_x+MOD:_x;}",
			"inline int&sub1(int&_x,int _y){return (_x-=_y)<0?_x+=MOD:_x;}",
			"template<typename...args>inline int&sub1(int&_x,args..._y){return (_x-=add0(_y...))<0?_x+=MOD:_x;}",
			"inline int sub0(inlsi _x,inlsi _y){return sub0(add0(_x),add0(_y));}",
			"inline int&sub1(int&_x,inlsi _y){return sub1(_x,add0(_y));}",
			"inline int mul0(int _x,int _y){return int(1ll*_x*_y%MOD);}",
			"template<typename...args>inline int mul0(int _x,args..._y){return int(1ll*_x*mul0(_y...)%MOD);}",
			"inline int&mul1(int&_x,int _y){return _x=int(1ll*_x*_y%MOD);}",
			"template<typename...args>inline int&mul1(int&_x,args..._y){return _x=int(1ll*_x*mul0(_y...)%MOD);}",
			"inline int mul0(inlsi _x){int _y=1;for(int _i:_x)mul1(_y,_i);return _y;}",
			"inline int&mul1(int&_x,inlsi _y){return mul1(_x,mul0(_y));}",
			"inline int qp(int _x,int _y){int _t=1;for(;_y;_y>>=1,mul1(_x,_x))if(_y&1)mul1(_t,_x);return _t;}",
			"inline int _inv(int _x){return qp(_x,MOD-2);}",
			"inline int div0(int _x,int _y){return mul0(_x,_inv(_y));}",
			"template<typename...args>inline int div0(int _x,args..._y){return mul0(_x,_inv(mul0(_y...)));}",
			"inline int&div1(int&_x,int _y){return _x=mul0(_x,_inv(_y));}",
			"template<typename...args>inline int&div1(int&_x,args..._y){return _x=mul0(_x,_inv(mul0(_y...)));}",
			"inline int div0(inlsi _x,inlsi _y){return div0(mul0(_x),mul0(_y));}",
			"inline int&div1(int&_x,inlsi _y){return div1(_x,mul0(_y));}"
		]
	},
	"珂朵莉树": {
		"scope": "cpp",
		"prefix": "add_odt",
		"body": [
			"struct odt_node{",
			"\tint l,r;mutable int val;",
			"\todt_node(int a=0,int b=0,int c=0):l(a),r(b),val(c){}",
			"\tbool operator<(const odt_node &t)const{return l<t.l;}",
			"};",
			"struct odt:std::set<odt_node>{",
			"\tauto split(int p){",
			"\t\tauto it=lower_bound(p);",
			"\t\tif(it!=end()&&it->l==p)return it;",
			"\t\tauto t=*--it;erase(it);emplace(t.l,p-1,t.val);",
			"\t\treturn emplace(p,t.r,t.val).first; ",
			"\t}",
			"\tauto assign(int l,int r,int k){",
			"\t\terase(split(l),split(r+1));",
			"\t\treturn emplace(l,r,k).first;",
			"\t}",
			"};"
		]
	},
	"bsgs/exbsgs": {
		"scope": "cpp",
		"prefix": "add_bsgs",
		"body": [
			"int bsgs(int a,int b,int p){",
			"\tstd::unordered_map<int,int>map;",
			"\tint size=ceil(sqrt(p)),mul=b;",
			"\tfor(int i=1;i<=size;i++)map[mul=mul*a%p]=i;",
			"\tint step=qp(a,size,p);mul=1;",
			"\tfor(int i=1;i<=size;i++)if(map.count(mul=mul*step%p))return i*size-map[mul];",
			"\treturn -1;",
			"}",
			"inline int exbsgs(int a,int b,int p){",
			"\tif(b==1||p==1)return 0;",
			"\tint g=std::gcd(a,p),cnt=0,mul=1;",
			"\twhile(g!=1){",
			"\t\tif(b%g)return -1;",
			"\t\tb/=g;p/=g;",
			"\t\tcnt++;mul=mul*a/g%p;",
			"\t\tif(mul==b)return cnt;",
			"\t\tg=std::gcd(a,p);",
			"\t}",
			"\tint ans=bsgs(a,b*_inv(mul,p)%p,p);",
			"\tif(ans==-1)return -1;",
			"\treturn ans+cnt;",
			"}"
		]
	},
	"高精度重载运算符": {
		"scope": "cpp",
		"prefix": "add_bigint",
		"body": [
			"struct bigint{",
			"\tstd::vector<int>num;",
			"\tbigint &operator=(std::string s){",
			"\t\treverse(s.begin(),s.end());",
			"\t\tnum.resize(s.size());",
			"\t\tfor(size_t i=0;i<num.size();i++)num[i]=s[i]-48;",
			"\t\treturn *this;",
			"\t}",
			"\tbigint &operator=(int t){return *this=std::to_string(t);}",
			"\tbigint(){num.clear();}",
			"\tbigint(const int t){*this=std::to_string(t);}",
			"\tbigint &del0(){while(!num.empty()||num.back())num.pop_back();return *this;}",
			"\tvoid read(){std::string s;fio>>s;*this=s;}",
			"\tvoid write(){for(int i=num.size()-1;i>=0;i--)fio<<num[i];fio<<'\\n';}",
			"\tfriend bigint operator+(const bigint &x,const bigint &y){",
			"\t\tbigint res;res.num.resize(std::max(x.num.size(),y.num.size())+1);",
			"\t\tfor(size_t i=0;i<x.num.size();i++)res.num[i]+=x.num[i];",
			"\t\tfor(size_t i=0;i<y.num.size();i++)res.num[i]+=y.num[i];",
			"\t\tfor(size_t i=0;i<res.num.size();i++)if(res.num[i]>9)res.num[i]-=10,res.num[i+1]++;",
			"\t\treturn res.del0();",
			"\t}",
			"\tfriend bigint operator-(const bigint &x,const bigint &y){",
			"\t\tbigint res;res.num.resize(std::max(x.num.size(),y.num.size()));",
			"\t\tfor(size_t i=0;i<x.num.size();i++)res.num[i]+=x.num[i];",
			"\t\tfor(size_t i=0;i<y.num.size();i++)res.num[i]-=y.num[i];",
			"\t\tfor(size_t i=0;i<res.num.size();i++)if(res.num[i]<0)res.num[i]+=10,res.num[i+1]--;",
			"\t\treturn res.del0();",
			"\t}",
			"\tfriend bigint operator*(const bigint &x,const bigint &y){",
			"\t\tbigint res;res.num.resize(x.num.size()+y.num.size()+2);",
			"\t\tfor(size_t i=0;i<x.num.size();i++)for(size_t j=0;j<y.num.size();j++)res.num[i+j]+=x.num[i]*y.num[j];",
			"\t\tfor(size_t i=0;i<res.num.size();i++)if(res.num[i]>9)res.num[i+1]+=res.num[i]/10,res.num[i]%=10;",
			"\t\treturn res.del0();",
			"\t}",
			"\tfriend bigint operator*(const bigint &x,const int y){",
			"\t\tbigint res;res.num.resize(x.num.size()+10);",
			"\t\tfor(size_t i=0;i<x.num.size();i++)res.num[i]=x.num[i]*y;",
			"\t\tfor(size_t i=0;i<res.num.size();i++)if(res.num[i]>9)res.num[i+1]+=res.num[i]/10,res.num[i]%=10;",
			"\t\treturn res.del0();",
			"\t}",
			"\tfriend bigint operator/(const bigint &x,const int y){",
			"\t\tbigint res;int sum=0;res.num.resize(x.num.size());",
			"\t\tfor(int i=x.num.size()-1;i>=0;i--)sum=sum*10+x.num[i],res.num[i]=sum/y,sum%=y;",
			"\t\treturn res.del0();",
			"\t}",
			"\tfriend bigint operator%(const bigint &x,const int y){",
			"\t\tint res=0;",
			"\t\tfor(int i=x.num.size()-1;i>=0;i--)res=(res+x.num[i])%y;",
			"\t\treturn res;",
			"\t}",
			"\tfriend bool operator<(const bigint &x,const bigint &y){",
			"\t\tif(x.num.size()!=y.num.size())return x.num.size()<y.num.size();",
			"\t\tfor(int i=x.num.size()-1;i>=0;i--)if(x.num[i]!=y.num[i])return x.num[i]<y.num[i];",
			"\t\treturn 0;",
			"\t}",
			"\tfriend bool operator==(const bigint &x,const bigint &y){",
			"\t\tif(x.num.size()!=y.num.size())return 0;",
			"\t\tfor(int i=x.num.size()-1;i>=0;i--)if(x.num[i]!=y.num[i])return 0;",
			"\t\treturn 1;",
			"\t}",
			"};"
		]
	},
	"单数字求欧拉函数": {
		"scope": "cpp",
		"prefix": "add_phi",
		"body": [
			"inline int phi(int n){",
			"\tint ans=n;",
			"\tfor(int i=2;i*i<=n;i++)if(n%i==0){ans-=ans/i;while(n%i==0)n/=i;}",
			"\treturn n>1?ans-ans/n:ans;",
			"}"
		]
	},
	"线性求逆元": {
		"scope": "cpp",
		"prefix": "add_inv",
		"body": [
			"inv[1]=1;for(int i=2;i<=n;i++)inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;"
		]
	},
	"manacher": {
		"scope": "cpp",
		"prefix": "add_manacher",
		"body": [
			"void manacher(const std::string &b){",
			"\tstd::string a=\"~|\";",
			"\tfor(char it:b)a.push_back(it),a.push_back('|');",
			"\tint r=0,mid=0,la=a.length();",
			"\tfor(int i=1;i<la;i++){",
			"\t\tif(i<=r)hw[i]=std::min(hw[(mid<<1)-i],mid+hw[mid]-i);else hw[i]=1;",
			"\t\twhile(a[i-hw[i]]==a[i+hw[i]])hw[i]++;",
			"\t\tif(i+hw[i]>r)r=i+hw[i],mid=i;",
			"\t}",
			"}"
		]
	},
	"树状数组": {
		"scope": "cpp",
		"prefix": "add_BIT",
		"body": [
			"struct BIT{",
			"\tint data[N];",
			"\tvoid add(int x,int k=1){for(;x<=n;x+=x&-x)data[x]+=k;}",
			"\tint query(int x){int k=0;for(;x;x-=x&-x)k+=data[x];return k;}",
			"\tvoid updata(int l,int r,int k){add(l,k);add(r+1,-k);}",
			"};"
		]
	},
	"Miller_Rabin Pollard_Rho": {
		"scope": "cpp",
		"prefix": "add_rho",
		"body": [
			"namespace math{",
			"\tinline loli gcd(loli x,loli y){return y?gcd(y,x%y):x;}",
			"\tinline loli qp(venti a,loli b,loli MOD,loli t=1){if(b==0)return 1;for(;b;b>>=1,a=a*a%MOD)if(b&1)t=loli(a*t%MOD);return t;}",
			"\tinline auto abs(const auto &x){return x<0?-x:x;}",
			"\tbool isprime(loli n){",
			"\t\tconstexpr static int pr[]={2,325,9375,28178,450775,9780504,1795265022};",
			"\t\tif(n<2)return 0;",
			"\t\tloli a,b,k,x=0,y=n-1;",
			"\t\twhile(~y&1)x++,y>>=1;",
			"\t\tfor(int i=0;i<7&&pr[i]<n;i++){",
			"\t\t\ta=pr[i],b=qp(a,y,n);",
			"\t\t\tfor(int j=1;j<=x;j++){",
			"\t\t\t\tk=loli(venti(b)*b%n);",
			"\t\t\t\tif(k==1&&b!=1&&b!=n-1)return 0;",
			"\t\t\t\tb=k;",
			"\t\t\t}",
			"\t\t\tif(b!=1)return 0;",
			"\t\t}",
			"\t\treturn 1;",
			"\t}",
			"\tloli get_factor(loli n){",
			"\t\tloli c=rng()%(n-1)+1,L=1,cnt=1,pre=0,x=c%n,y=loli((venti(x)*x+c)%n),g=gcd(abs(x-y),n);",
			"\t\tif(g>1)return g;",
			"\t\twhile(x!=y){",
			"\t\t\tfor(int i=0;i<L;i++){",
			"\t\t\t\tx=loli((venti(x)*x+c)%n),y=loli((venti(y)*y+c)%n),y=loli((venti(y)*y+c)%n);",
			"\t\t\t\tpre=loli(venti(cnt)*abs(x-y)%n);",
			"\t\t\t\tif(x==y||!pre)break;",
			"\t\t\t\tcnt=pre;",
			"\t\t\t}",
			"\t\t\tg=gcd(cnt,n);",
			"\t\t\tif(g>1)return g;",
			"\t\t\tif(L<128)L<<=1;",
			"\t\t}",
			"\t\treturn n;",
			"\t}",
			"\tvoid prime_dfs(loli n,std::basic_string<loli>&ans){",
			"\t\tif(n<2)return;",
			"\t\tif(isprime(n)){ans+=n;return;}",
			"\t\tif(n==4){(ans+=2)+=2;return;}",
			"\t\tloli p=n;",
			"\t\twhile(p>=n)p=get_factor(n);",
			"\t\twhile(n%p==0)prime_dfs(p,ans),n/=p;",
			"\t\tprime_dfs(n,ans);",
			"\t}",
			"\tstd::basic_string<loli>factorization(loli x){",
			"\t\tstd::basic_string<loli>ans;",
			"\t\tprime_dfs(x,ans);",
			"\t\treturn ans;",
			"\t}",
			"}"
		]
	},
	"矩阵": {
		"scope": "cpp",
		"prefix": "add_matrix",
		"body": [
			"struct matrix{",
			"\tint data[107][107],size;",
			"\tmatrix(){}",
			"\tmatrix(const int &x):size(x){for(int i=0;i<=size;i++)std::fill_n(data[i],size+1,0);}",
			"\tvoid build(){for(int i=1;i<=size;i++)data[i][i]=1;}",
			"\tint *operator[](const int &t){return data[t];}",
			"\tconst int *operator[](const int &t)const{return data[t];}",
			"\tmatrix operator*(const matrix &t){",
			"\t\tmatrix res(size);",
			"\t\tfor(int k=1;k<=size;k++)for(int i=1;i<=size;i++)for(int j=1;j<=size;j++)",
			"\t\t\tres[i][j]=(res[i][j]+data[i][k]*t[k][j])%MOD;",
			"\t\treturn res;",
			"\t}",
			"\tmatrix &operator^=(int t){",
			"\t\tmatrix res(size);res.build();",
			"\t\tfor(;t;t>>=1,*this=*this**this)if(t&1)res=res**this;",
			"\t\treturn *this=res;",
			"\t}",
			"};"
		]
	}
}