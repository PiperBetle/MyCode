- ### [P7735 [NOI2021] 轻重边](https://www.luogu.com.cn/problem/P7735)

将重边定义为两端颜色相同的边，然后就很好做了，询问只要查询相邻两点颜色相同个数，修改只要链上覆盖一个新颜色。

树剖随便维护好了

---

- ### [P2403 [SDOI2010]所驼门王的宝藏](https://www.luogu.com.cn/problem/P2403)

重点在优化建图，可以考虑在同一行的横向门连成环，就不需要 $n^2$ 了，竖向同理。实现可以行列建虚点，向实际点连边，实际点连回来就是环上点了。任意门暴力 map 记录一下连边即可。

缩点跑 dp 结束。

---

- ### [P3625 [APIO2009] 采油区域](https://www.luogu.com.cn/problem/P3625)

考虑到网格上两个不交的矩形，必然可以用一条横线或竖线分在两个不同的区域内，显然可以推广到三个矩形。

然后就只需要四个角都做一遍 dp，然后大力分讨即可。

---

- ### [UVA11987 Almost Union-Find](https://www.luogu.com.cn/problem/UVA11987)

之前 LK 推的题，现在一看到发现不太理解，想明白了就写一下。

重点在操作二，考虑并查集直接移动一个点会导致它的儿子移动。但是路径压缩后，就只会有根节点的移动不满足题意，其他都是叶子。

那就让根节点变成叶子，在每个点上都建个虚点父亲，路径压缩后所有点都只连向虚点，二操作移动就不影响其他点了。

考虑移来移去和合并会导致虚点变单点，但是没有分裂，最后所有点都合并了，一二操作无效，故正确性无误。

---

- ### [CF1530E Minimax](https://www.luogu.com.cn/problem/CF1530E)

要让重排之后的所有前缀的 $\operatorname{Border}$ 长度的最大值最小，由于是输出方案（还要求字典序），所以考虑能否直接构造，而不考虑 $\operatorname{Border}$ 性质。

1. 只有一个字符肯定直接直接输出。
    
2. 由特殊出发，考虑什么时候答案为 0，即存在一个字符只出现一次，放开头，剩下随便放。

3. 然后个人认为最难发现的一步，就是可以发现答案最大为 1。

	- 考虑设 $x$ 为其中一个字符，$y$ 为其他字符，$xyyy\dots yxxx\dots$ 满足答案为 1。
    
   接下来就只要构造出字典序最小。
	- 如果字典序最小的字符个数少于一半，$xxyxyx\dots yxyyy\dots$。
    
	- 否则，上面的构造就挂了（$xxy\dots yxx\dots$），所以开头只放一个 $x$，然后放第二大，再把 $x$ 放完后需要放一个 $z$ (防止 $xy$ 形成 $\operatorname{Border}$），其他直接放。
    
		- 如果没有 $z$ 就需要放完 $y$。

要一步一步推出这个结论对我来说还是相对 hard ![](//图.tk/7)。

---

听后置讲的，也多更一点吧。

- ### [如果我让你查回文你还爱我吗](https://ac.nowcoder.com/acm/problem/204306)

首先可以观察到，一个子串左半边才会被 $l$ 卡，右半才会被 $r$ 卡，考虑拆成两个询问做。

以右半为例，随便推一下就可以得到满足 $r-i+1>hw_i$ 的贡献是 $hw_i$，其余的贡献是 $r-i+1$。故先把询问离线，按 $r$ 从小到大做，把  $hw_i+i-1,(hw_i+i-1<r)$ 塞到树状数组对应位置，把 $1,(hw_i+i-1>r)$ 塞到另一个树状数组对应位置。统计答案只需要 $\sum\limits_{i=l}^r tree_{1,i}-\sum\limits_{i=l}^r tree_{2,i}\times r-\sum\limits_{i=l}^r i$，手玩一下还是比较好理解的。

左半边同理，左右加起来就好了。

upd：突然发现不用左区间对左端点，右区间对右端点，直接都做一遍就可以，细节 --，码量 double

---

还是好咕，但是只剩一个月了，还在板刷 2100~2300，有空更点

- ### [CF1550D Excellent Arrays](https://www.luogu.com.cn/problem/CF1550D)

首先一步小转化，把直接填数，改为设 $a_i=i+x_i,(x_i\neq 0)$，然后就有很多可以发现，$F(a)$ 就是 $x_i$ 相等的对数，要满足第三个条件，就有 $|x_i|$ 全部相等并且分配的尽量平均。

考虑怎么计算答案，先想到可以暴力枚举 $|x|$，根据每个数能填的上下界分为 $x_i>0$ 和 $x_i<0$ 以及都可以，都可以的部分组合数算一下就可以了。

然后发现只和这几个的数量有关，而变化的次数是 $O(n)$ 的，就做完了。

---

- ### [CF1552E Colors and Intervals](https://www.luogu.com.cn/problem/CF1552E)

想题效率好低，自己 P 性质都发现不了。

考虑 $\lceil \frac{n}{k-1} \rceil$ 这个东西的意义，但是直接想发现什么都不是。但是考虑 $k-1$，因为一个颜色的点有 $k$ 个，这就构成了 $k-1$ 个区间。而 $(k-1)\lceil \frac{n}{k-1} \rceil \ge n$，这就能想到是否可以把原序列劈成 $k-1$ 段，每段最多被覆盖 $\lceil \frac{n}{k-1} \rceil$ 次。

考虑第 $i$ 段区间，按每个颜色第 $i$ 个区间的右端点排序，选前 $\lceil \frac{n}{k-1} \rceil$ 个区间，然后去做第 $i+1$ 段区间。

这样每段区间是不交的，并且最多做 $k-1$  段，大概理解一下就可以发现所有颜色一定可以做完。

---

- ### [CF1553E Permutation Shift](https://www.luogu.com.cn/problem/CF1553E)

没看到 $m\le\frac{n}{3}$，还很困，大概就想了下暴力枚举 $k$，就直接开题解了。

首先可以把两种操作顺序换一下，设一个 $cnt$ 表示平移之后不用变的数的个数，如果 $k$ 满足条件，那就有 $cnt\ge n-m\times2$，又因为 $m\le\frac{n}{3}$，所以 $cnt\ge\frac{n}{3}$。又因为 $\sum cnt=n$，所以就可以发现最多只有 $3$ 个 $k$ 能满足这个条件，那就可以直接来了。

现在问题就变成了计算一个排列到另一个最少要交换几次，典了，原位置向目标位置建边，每一条边都是一次交换，每一个环可以减少一次，这个可以 $O(n)$ 求。

---

- ### [CF1584E Game with Stones](https://www.luogu.com.cn/problem/CF1584E)

发现要满足条件的区间满足奇位和等于偶位和，子区间计数，考虑移动右端点实时维护。

例如当前 $r$ 是奇数位，要维护的值形如 $\sum\limits_{i}^{r}(-1)^{r-i}a_i$，其中等于 $-a_r$ 的数即为答案，考虑开桶计数，但是加数需要在每一项都加一个 $a_r$，很难做，就变成维护每个值前面缺的那段，实现时就只需要减当前总和即可。

然后这个并不充分，考虑需要每次操作后都为非负数才行。同样以维护奇数位答案的桶为例，加一个奇数位的数后，若桶里维护的某个值为负数直接删去，因为到目前这步操作就不合法了；加一个偶数位的数后，若桶里维护的某个值为正数直接删去，因为目前到这一位实际的操作后的值，是桶内值的相反数。

偶数位同理。

---

- ### [CF1592D Hemose in ICPC ?](https://www.luogu.com.cn/problem/CF1592D)

shaber。shaber。shaber。

欧拉序的区间是个连通块。欧拉序的区间是个连通块。欧拉序的区间是个连通块。

对欧拉序二分即可。

---

- ### [P6593 [YsOI2020]义已失吾亦死](https://www.luogu.com.cn/problem/P6593)

¿ 很容易想假 ¿

先想到一个 $f_{i,x,y,z}$ 表示到第 $i$ 位，取了 $x$ 个 $4$，取了 $y$ 个 $5$，模 $p$ 是 $z$ 的最大值，但是空间爆了，并且很难优化。

因此考虑转为可行性 dp，之后贪心从高位构造出答案。

就可以压位来优化了，状态变成 $f_{i,x,y}$ 里面存一个 64 位整数，表示到第 $i$ 位，取了 $x$ 个 $4$，取了 $y$ 个 $5$，可行的余数有哪些。

---

- ### [CF1553F Pairwise Modulo](https://www.luogu.com.cn/problem/CF1553F)

考虑加入一个数的贡献，分成 $\le a_i$ 和 $\ge a_i$ 两部分，$p_i=p_{i-1}+\sum\limits_{j=1}^{i-1}a_j\bmod a_i+\sum\limits_{j=1}^{i-1} a_i\bmod a_j$。

前半部分有 $a_j\bmod a_i=a_j-ka_i$，又拆成两部分，后半部分枚举 $k$，统计 $[ka_i,(k+1)a_i)$ 内的的 $a_j$ 个数，插入数单点更新，用树状数组维护。

后半部分有 $a_i\bmod a_j=a_i-\left\lfloor\frac{a_i}{a_j}\right\rfloor a_j$，同样分两部分，后半部分插入数时对于每个 $ka_i$ 的位置加一个 $a_i$，查询就只需要 $[1,a_i]$ 求和，依然是树状数组维护一下。

因为 $a_i$ 互不相同，复杂度 $O(n\ln V\log V)$。

---

- ### [CF1743F Intersection and Union](https://www.luogu.com.cn/problem/CF1743F)

值域很小，考虑把贡献拆到每个位置，那就可以设一个 $dp_{j,0/1}$ 位置 $j$ 当前是否被覆盖的方案数，枚举每个区间转移。

考虑怎么优化，想到依次扫过去，有区间进出总共只有 $O(n)$。

怎么利用呢，考虑维护 $n$ 个转移，每个转移可看成 $2\times 2$ 的矩阵，使用线段树，进出区间时单点修改，`push_up` 就是矩阵相乘，最后随便统计一下就好了。

---

- ### [CF1601C Optimal Insertion](https://www.luogu.com.cn/problem/CF1601C)

首先可以发现 $b$ 的元素之间肯定不会产生贡献，因此需要最小化的就是 $a,b$ 间的贡献。

然后发现插入一个数的贡献是前面比它大的数，和后面比它小的数，这个东西可以在值域上扫过去，利用线段树维护插在每个位置的贡献，插入数就直接查询最小值即可。

但是为什这能保证 $b$ 是从小到大的呢，其实也不难证，考虑这个维护的贡献数组，可以理解为每次向后交换一位产生贡献的前缀和，一个数变大之后，贡献中 $1$ 变少，$-1$ 变多，如果最优位置会向前移，那么这个位置一定不优于前一个的位置。

借助这个性质，也同样有了一个分治做法。

考虑 $\text{solve}(l_1,r_1,l_2,r_2)$ 表示把 $b$ 中 $[l_1,r_1]$ 塞到 $a$ 中 $[l_2,r_2]$ 中。

每次考虑 $b_{mid}$ 插到哪个位置，由于无论插到哪里都与区间外的无关，所以只要区间内产生的贡献最小，直接暴力找，均摊一下就是对的。

---

模拟赛不记就寄了。

- ### [10.15](https://smallpdf.com/cn/file#s=7baaa490-a233-4525-bef5-3f96fc409236)

- T3

很容易想到树形 dp，$f_{i,0/1/2/3}$，表示以 $i$ 为根，延伸上来链长为 $0/1/2/3$ 的答案。转移就相当于确定每个子树延伸的链长，$2,2$、$1,3$ 相匹配，最后只剩一个数。

不关心具体怎么匹配，可设 $g_{t,i,j,k}$ 表示前 $t$ 个数选择 $1,2,3$ 个数为 $i,j,k$ 的最大值，直接转移，$O(n^4)$。

考虑简化状态，最后要求的东西只和差值相关，状态简化为 $g_{t,i,0/1}$ 表示 $1,3$ 个数之差，以及 $2$ 的个数的奇偶性，$O(n^2)$。

瓶颈在这个 $i$，考虑被卡满的情况是先选了一堆 $1$，再选了一堆 $3$，这就可以发现 `shuffle` 之后会变优，可以证明最大前缀和期望是 $O(\sqrt n)$¿，$O(n\sqrt n)$。

---

- ### [10.18](https://smallpdf.com/cn/file#s=dad260de-dc48-48a7-924c-595a04c3b822)

引荐人 mak。

- T1

Nim 游戏，场上降智商了。

等价于找两组数 $x\oplus y=z\oplus w$，暴力找，拿桶记一下。

因为两两不同，不会出现一个数异或两个不同数相等，值域也不大，所以复杂度是对的。

- T2

其实并不是很 hard，考虑只会删去一个操作，也就是说终点只会有一格的位移，即四个终点。

直接从前向后扫，同时维护四条后缀路径，并且将已经过的前缀加进去，进过次数的加减其实也只需要加减最大的那次即可。

- T3

数数能力为 0 了属于是。

设 $g_i$ 为值域为 $1\sim i$，且恰好都出现时好序列的数量，答案为 $\sum\limits_{i=1}^{n}\binom{m}{i}g_i$，暴力求 $g_i$ 是 $O(n^n\times n)$ 的，场上连这个都不会、、、

求 $g_i$ 相对困难，限制放松一点，设 $f_i$ 表示值域为 $1\sim i$ 的答案，可以用二项式反演求 $g_i$。

然后考虑怎么求 $f_i$，可以钦定若干点不合法，将序列分成多段，设 $h_{i,j}$ 为前 $i$ 段，最大值为 $j$ 的方案数。转移简单容斥下值域上两个端点，不难，$O(2^n\text{poly}(n))$。

考虑能否不直接枚举端点，因为从前向后转移，在之前就把不合法的给噶了，之后就只需要枚举最近的那个不合法的点就即可，状态 $f_{i,j}$ 表示序列长为 $i$，值域为 $j$ 的方案数，枚举第一个不合法点转移。
$$
f_{i,j}=j^i-\sum\limits_{x=1}^{i-1}\sum\limits_{y=1}^{j}(f_{x,y}-f_{x,y-1})((j-y+1)^{i-x}-(j-y)^{i-x})
$$

$f_{x,y}-f_{x,y-1}$ 限制了枚举的点前一段最大值，$(j-y+1)^{i-x}-(j-y)^{i-x}$ 限制了后一段的最小值。

$O(n^4)$ 的，先固定 $j,y$ 后可以 $O(n^3)$ ¿

---

- ### [10.19](https://smallpdf.com/cn/file#s=52a2e4eb-b6f4-4513-b405-a3f04c988b7c)

- T2

数据烂了，随便乱写一个假做法就 80。

对于 $a_i=1$ 肯定是加，否则最多选择一个做加法，因为做两个加法不如加大的后乘二。

考虑两个数加一个乘一个哪个加更优，拿这个做 `cmp` 排个序再判断加不加做完了。

- T3

场上想到了分成 $?$ 多和 $?$ 少的做，没继续想下去，怒砍与暴力记忆化同分的高分。

并且场上还写的非常降智复杂度里还多乘一个 $L$。

$?$ 少的情况，暴力枚举直接做。

$1$ 少的情况，考虑把所有 $?$ 也看成 $1$，直接求子集和，但是直接加会把一部分 $1$ 当作 $0$ 的也加上，枚举 $1$ 状态，简单容斥即可。

$0$ 少的情况，考虑把所有 $?$ 也看成 $0$，直接求超集和，同样会把一部分 $0$ 当成 $1$，所以枚举 $0$ 状态简单容斥。

子集超集和是典高维前缀和。

- T4

欧拉公式¿ 阿拉丁扫描线¿ 大 DS 现在不是很写的动。

---

- ### [10.21](https://smallpdf.com/cn/file#s=105159b0-ff5e-4940-87ac-1e4489d5732e)

数？树？寄

- T2

二项式反演 P 都不会

肯定是拍成一个排列，要 $p_{i+1}$ 是 $p_i$ 祖先恰好为 $y$。 

设 $dp_{i,j}$ 表示在 $i$ 子树内，跳至少 $j$ 次祖先的方案数，子树间互不影响，转移可以树上背包，然后再把根加进去，注意加在跳祖先过程中间不会多产生贡献，即 $dp_{i,j}=dp_{i,j-1}\times(siz_i-1-j)$。

但是树上背包的结果还是无序的方案数，跳祖先的点对捆绑，即乘一个 $(siz_i-j)!$。

每个询问跑一遍二项式反演即可。

- T3

等价于求深度最小的点分树。

然后考虑把一个点在点分树里向下的距离设为权值，那就要求原树上两个相等的点之间有一个更大的点。

那就可以开始 dp 了，$f_{i,j}$ 表示以 $i$ 为根子树到 $i$ 路上没有更大权值的点的集合为 $j$，转移就把每个子树取并，若有交集，该点权值就要大于交集最大值。

因为要最大值最小，每次贪心取 highbit 即可。

---

- ### [10.22](https://smallpdf.com/cn/file#s=b80b0f52-f412-4aef-8776-2fc269d7cd5d)

- T1

其实整理一下，所有行列的操作次数都可用第一行的操作次数表示，取个中位数即可。

- T2

同样降智了，赛时拆了前两位和后四位，还是 $|\sum|^2$ 的。

拆前四位和后两位，前四位直接枚举两个字符暴力递推，后两位随便算一下就好了。

前四位的部分均摊后复杂度是对的，$O(n|\sum |)$。

---

- ### [CF1614D2 Divan and Kostomuksha](https://www.luogu.com.cn/problem/CF1614D2)

丑王之王。

看到值域不是很大，考虑在值域上 dp。

设 $f_i$ 为当前 GCD 为 $i$ 的最大答案，那就能从 $f_{ki}$ 中取最大值转移，注意要把 $i\times cnt_i$ 中算重的部分减掉，$cnt_i$ 为含有因数 $i$ 的数的个数，根号预处理即可。

但是过不去 hv，注意到 $f_{i}$ 只从 $f_{p_j\times i},p_j\in P$，转移是有效的，其他都可以通过这些转移到。

但是被卡常了¿

---

- ### [CF1615D X(or)-mas Tree](https://www.luogu.com.cn/problem/CF1615D)

注意到 popcount 的奇偶性只需要通过二进制中最后一位就可改变。

---

CSP 没有很炸，继续板刷，终于自己过了几个题，很有感觉

- ### [CF1622E Math Test](https://www.luogu.com.cn/problem/CF1622E)

对着 $n\le 10$ 愣是什么都想不出。

有个绝对值很难处理，考虑枚举哪些是正的，式子就可以变成 $\sum(r_i-s_i)\times c_i$，接下就可以推推推了。

$$
\begin{aligned}
&=
\sum\limits_{i=1}^n r_i\times c_i - \sum\limits_{i=1}^n s_i\times c_i
\\
&=
\sum\limits_{i=1}^n r_i\times c_i - \sum\limits_{i=1}^n \left(\sum\limits_{j=1}^m a_j\times p_{i,j}  \right)\times c_i
\\
&=
\sum\limits_{i=1}^n r_i\times c_i - \sum\limits_{j=1}^m \left(\sum\limits_{i=1}^n c_i\times p_{i,j}  \right)\times a_i
\end{aligned}
$$

只要搞出一个 $a$ 使减号后面最小即可，后面形式也很好，直接排序不等式即可。

---

- ### [CF1625D Binary Spiders](https://www.luogu.com.cn/problem/CF1625D)

首先发现一个序列两两 $\text{Xor}$ 最小值是排序后的 $\text{min}\{a_i\oplus a_{i+1}\}$，就可以